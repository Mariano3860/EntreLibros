<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/frontend/src/components/publish/PublishBookModal/PublishBookModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/publish/PublishBookModal/PublishBookModal.tsx" />
              <option name="originalContent" value="import { useBookSearch } from '@hooks/api/useBookSearch'&#10;import { usePublishBook } from '@hooks/api/usePublishBook'&#10;import { useFocusTrap } from '@hooks/useFocusTrap'&#10;import { usePublishDraft } from '@hooks/usePublishDraft'&#10;import { stripDraftMeta } from '@utils/drafts'&#10;import isEqual from 'lodash/isEqual'&#10;import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'&#10;import { useTranslation } from 'react-i18next'&#10;import { toast } from 'react-toastify'&#10;&#10;import { PublishBookPayload } from '@src/api/books/publishBook.types'&#10;import { ApiBookSearchResult } from '@src/api/books/searchBooks.types'&#10;import { MAX_IMAGES_UPLOAD } from '@src/constants/constants'&#10;&#10;import { IdentifyStep } from './components/IdentifyStep'&#10;import { OfferStep } from './components/OfferStep'&#10;import { PublishBookStepper } from './components/PublishBookStepper'&#10;import { ResumeDraftPrompt } from './components/ResumeDraftPrompt'&#10;import { ReviewStep } from './components/ReviewStep'&#10;import {&#10;  STORAGE_KEY,&#10;  genres,&#10;  initialState,&#10;  stepIndex,&#10;  stepOrder,&#10;  toSerializableDraft,&#10;} from './PublishBookModal.constants'&#10;import styles from './PublishBookModal.module.scss'&#10;import {&#10;  PublishBookDraftState,&#10;  PublishBookFormState,&#10;  PublishBookImage,&#10;  PublishBookMetadata,&#10;  PublishBookOffer,&#10;} from './PublishBookModal.types'&#10;import {&#10;  ensureCover,&#10;  getPreviewCover,&#10;  sanitizeDraft,&#10;} from './PublishBookModal.utils'&#10;import { useDebouncedValue } from './useDebouncedValue'&#10;&#10;type PublishBookModalProps = {&#10;  isOpen: boolean&#10;  onClose: () =&gt; void&#10;  onPublished: (bookId: string) =&gt; void&#10;}&#10;&#10;const usePublishBookDraft = () =&gt;&#10;  usePublishDraft&lt;PublishBookDraftState&gt;({ storageKey: STORAGE_KEY })&#10;&#10;const usePublishState = (draft: PublishBookDraftState | null) =&gt; {&#10;  const [state, setState] = useState&lt;PublishBookFormState&gt;(initialState)&#10;  const [showDraftPrompt, setShowDraftPrompt] = useState(false)&#10;  const [autosaveEnabled, setAutosaveEnabled] = useState&lt;boolean&gt;(() =&gt; !draft)&#10;&#10;  return {&#10;    state,&#10;    setState,&#10;    showDraftPrompt,&#10;    setShowDraftPrompt,&#10;    autosaveEnabled,&#10;    setAutosaveEnabled,&#10;  }&#10;}&#10;&#10;const useDraftInitialization = (&#10;  isOpen: boolean,&#10;  draft: PublishBookDraftState | null,&#10;  setState: React.Dispatch&lt;React.SetStateAction&lt;PublishBookFormState&gt;&gt;,&#10;  setShowDraftPrompt: React.Dispatch&lt;React.SetStateAction&lt;boolean&gt;&gt;,&#10;  setAutosaveEnabled: React.Dispatch&lt;React.SetStateAction&lt;boolean&gt;&gt;&#10;) =&gt; {&#10;  const initializedRef = useRef(false)&#10;&#10;  useEffect(() =&gt; {&#10;    if (!isOpen) {&#10;      initializedRef.current = false&#10;      setShowDraftPrompt(false)&#10;      setAutosaveEnabled(true)&#10;      return&#10;    }&#10;&#10;    if (initializedRef.current) return&#10;&#10;    initializedRef.current = true&#10;    if (draft) {&#10;      setShowDraftPrompt(true)&#10;      setAutosaveEnabled(false)&#10;    } else {&#10;      setState(initialState)&#10;      setAutosaveEnabled(true)&#10;    }&#10;  }, [draft, isOpen, setAutosaveEnabled, setShowDraftPrompt, setState])&#10;}&#10;&#10;const useBodyScrollLock = (isOpen: boolean) =&gt; {&#10;  useEffect(() =&gt; {&#10;    if (!isOpen) return&#10;    document.body.style.overflow = 'hidden'&#10;    return () =&gt; {&#10;      document.body.style.overflow = ''&#10;    }&#10;  }, [isOpen])&#10;}&#10;&#10;export const PublishBookModal: React.FC&lt;PublishBookModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  onPublished,&#10;}) =&gt; {&#10;  const { t, i18n } = useTranslation()&#10;  const {&#10;    draft: storedDraft,&#10;    saveNow,&#10;    scheduleSave,&#10;    clear,&#10;  } = usePublishBookDraft()&#10;  const draft = useMemo(() =&gt; stripDraftMeta(storedDraft), [storedDraft])&#10;  const {&#10;    state,&#10;    setState,&#10;    showDraftPrompt,&#10;    setShowDraftPrompt,&#10;    autosaveEnabled,&#10;    setAutosaveEnabled,&#10;  } = usePublishState(draft)&#10;  const modalRef = useRef&lt;HTMLDivElement&gt;(null)&#10;&#10;  useDraftInitialization(&#10;    isOpen,&#10;    draft,&#10;    setState,&#10;    setShowDraftPrompt,&#10;    setAutosaveEnabled&#10;  )&#10;  useBodyScrollLock(isOpen)&#10;&#10;  const baselineDraft = useMemo&lt;PublishBookDraftState&gt;(&#10;    () =&gt; draft ?? toSerializableDraft(initialState),&#10;    [draft]&#10;  )&#10;  const serializableState = useMemo&lt;PublishBookDraftState&gt;(&#10;    () =&gt; toSerializableDraft(state),&#10;    [state]&#10;  )&#10;&#10;  const debouncedQuery = useDebouncedValue(state.searchQuery)&#10;  const {&#10;    data: results,&#10;    isFetching,&#10;    isError,&#10;    refetch,&#10;  } = useBookSearch(debouncedQuery)&#10;  const { mutateAsync, isPending } = usePublishBook()&#10;  const baseState = useMemo(() =&gt; sanitizeDraft(draft), [draft])&#10;&#10;  const closeWithConfirmation = useCallback(() =&gt; {&#10;    const hasChanges = !isEqual(serializableState, baselineDraft)&#10;    if (hasChanges) {&#10;      const confirmed = window.confirm(t('publishBook.confirmClose'))&#10;      if (!confirmed) {&#10;        return&#10;      }&#10;    }&#10;    onClose()&#10;  }, [baselineDraft, onClose, serializableState, t])&#10;&#10;  useFocusTrap({&#10;    containerRef: modalRef,&#10;    active: isOpen &amp;&amp; !showDraftPrompt,&#10;    onEscape: closeWithConfirmation,&#10;  })&#10;&#10;  useEffect(() =&gt; {&#10;    if (!isOpen) return&#10;    const handleBeforeUnload = (event: BeforeUnloadEvent) =&gt; {&#10;      if (!isEqual(serializableState, baselineDraft)) {&#10;        event.preventDefault()&#10;        event.returnValue = ''&#10;      }&#10;    }&#10;    window.addEventListener('beforeunload', handleBeforeUnload)&#10;    return () =&gt; {&#10;      window.removeEventListener('beforeunload', handleBeforeUnload)&#10;    }&#10;  }, [baselineDraft, isOpen, serializableState])&#10;&#10;  useEffect(() =&gt; {&#10;    if (!isOpen || showDraftPrompt || !autosaveEnabled) return&#10;    if (isEqual(serializableState, baselineDraft)) return&#10;    scheduleSave(serializableState)&#10;  }, [&#10;    autosaveEnabled,&#10;    baselineDraft,&#10;    isOpen,&#10;    scheduleSave,&#10;    serializableState,&#10;    showDraftPrompt,&#10;  ])&#10;&#10;  const handleBlur = useCallback&lt;React.FocusEventHandler&lt;HTMLElement&gt;&gt;(() =&gt; {&#10;    if (!autosaveEnabled) return&#10;    scheduleSave(serializableState)&#10;  }, [autosaveEnabled, scheduleSave, serializableState])&#10;&#10;  const updateMetadata = useCallback(&#10;    (update: Partial&lt;PublishBookMetadata&gt;) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; {&#10;        const metadata = { ...prev.metadata, ...update }&#10;        const nextImages = ensureCover(prev.images, metadata.coverUrl)&#10;        return { ...prev, metadata, images: nextImages }&#10;      })&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const updateOffer = useCallback(&#10;    (update: Partial&lt;PublishBookOffer&gt;) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        offer: { ...prev.offer, ...update },&#10;      }))&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const updateDelivery = useCallback(&#10;    (update: Partial&lt;PublishBookOffer['delivery']&gt;) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        offer: {&#10;          ...prev.offer,&#10;          delivery: { ...prev.offer.delivery, ...update },&#10;        },&#10;      }))&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const toggleTradePreference = useCallback(&#10;    (genre: PublishBookOffer['tradePreferences'][number]) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; {&#10;        const isActive = prev.offer.tradePreferences.includes(genre)&#10;        const tradePreferences = isActive&#10;          ? prev.offer.tradePreferences.filter((item) =&gt; item !== genre)&#10;          : [...prev.offer.tradePreferences, genre]&#10;        return {&#10;          ...prev,&#10;          offer: { ...prev.offer, tradePreferences },&#10;        }&#10;      })&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const handleResult = useCallback(&#10;    (result: ApiBookSearchResult) =&gt; {&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        metadata: {&#10;          ...prev.metadata,&#10;          title: result.title ?? prev.metadata.title,&#10;          author: result.author ?? prev.metadata.author,&#10;          publisher: result.publisher ?? prev.metadata.publisher,&#10;          year: result.year ? String(result.year) : prev.metadata.year,&#10;          language:&#10;            result.language ?? prev.metadata.language ?? i18n.language ?? '',&#10;          format: result.format ?? prev.metadata.format,&#10;          isbn: result.isbn ?? prev.metadata.isbn,&#10;          coverUrl: result.coverUrl ?? prev.metadata.coverUrl,&#10;        },&#10;        manualMode: false,&#10;        images: ensureCover(&#10;          prev.images,&#10;          result.coverUrl ?? prev.metadata.coverUrl&#10;        ),&#10;      }))&#10;      toast.info(t('publishBook.prefilled'))&#10;      setAutosaveEnabled(true)&#10;    },&#10;    [i18n.language, setAutosaveEnabled, setState, t]&#10;  )&#10;&#10;  const handleFiles = useCallback(&#10;    async (files: FileList | null) =&gt; {&#10;      if (!files) return&#10;      const fileArray = Array.from(files).slice(0, MAX_IMAGES_UPLOAD)&#10;      const uploads = await Promise.all(&#10;        fileArray.map(&#10;          (file, index) =&gt;&#10;            new Promise&lt;PublishBookImage&gt;((resolve, reject) =&gt; {&#10;              const reader = new FileReader()&#10;              reader.onload = () =&gt;&#10;                resolve({&#10;                  id: `${file.name}-${Date.now()}-${index}`,&#10;                  url: String(reader.result),&#10;                  source: 'upload',&#10;                  name: file.name,&#10;                })&#10;              reader.onerror = () =&gt;&#10;                reject(reader.error ?? new Error('Failed to read file'))&#10;              reader.readAsDataURL(file)&#10;            })&#10;        )&#10;      )&#10;      setState((prev) =&gt; {&#10;        const nextImages = [...prev.images, ...uploads].slice(&#10;          0,&#10;          MAX_IMAGES_UPLOAD&#10;        )&#10;        return { ...prev, images: nextImages }&#10;      })&#10;      setAutosaveEnabled(true)&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const removeImage = useCallback(&#10;    (id: string) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        images: prev.images.filter((image) =&gt; image.id !== id),&#10;      }))&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const nextStep = useCallback(() =&gt; {&#10;    setAutosaveEnabled(true)&#10;    setState((prev) =&gt; ({&#10;      ...prev,&#10;      step: prev.step === 'identify' ? 'offer' : 'review',&#10;    }))&#10;  }, [setAutosaveEnabled, setState])&#10;&#10;  const previousStep = useCallback(() =&gt; {&#10;    setAutosaveEnabled(true)&#10;    setState((prev) =&gt; ({&#10;      ...prev,&#10;      step: prev.step === 'review' ? 'offer' : 'identify',&#10;    }))&#10;  }, [setAutosaveEnabled, setState])&#10;&#10;  const coverUrl = useMemo(&#10;    () =&gt; getPreviewCover(state.images, state.metadata.coverUrl),&#10;    [state.images, state.metadata.coverUrl]&#10;  )&#10;&#10;  const identifyErrors = useMemo(() =&gt; {&#10;    const errors: Record&lt;string, string&gt; = {}&#10;    if (!state.metadata.title.trim()) {&#10;      errors.title = t('publishBook.errors.title')&#10;    }&#10;    if (!state.metadata.author.trim()) {&#10;      errors.author = t('publishBook.errors.author')&#10;    }&#10;    if (!state.metadata.language.trim()) {&#10;      errors.language = t('publishBook.errors.language')&#10;    }&#10;    if (!state.metadata.format.trim()) {&#10;      errors.format = t('publishBook.errors.format')&#10;    }&#10;    if (!coverUrl) {&#10;      errors.images = t('publishBook.errors.image')&#10;    }&#10;    return errors&#10;  }, [coverUrl, state.metadata, t])&#10;&#10;  const offerErrors = useMemo(() =&gt; {&#10;    const errors: Record&lt;string, string&gt; = {}&#10;    if (!state.offer.condition) {&#10;      errors.condition = t('publishBook.errors.condition')&#10;    }&#10;    if (!state.offer.sale &amp;&amp; !state.offer.trade &amp;&amp; !state.offer.donation) {&#10;      errors.modes = t('publishBook.errors.modes')&#10;    }&#10;    if (state.offer.sale) {&#10;      const amount = Number(state.offer.priceAmount)&#10;      if (!state.offer.priceAmount || Number.isNaN(amount) || amount &lt;= 0) {&#10;        errors.price = t('publishBook.errors.price')&#10;      }&#10;    }&#10;    return errors&#10;  }, [state.offer, t])&#10;&#10;  const canProceedIdentify = useMemo(&#10;    () =&gt; Object.keys(identifyErrors).length === 0,&#10;    [identifyErrors]&#10;  )&#10;  const canProceedOffer = useMemo(&#10;    () =&gt; Object.keys(offerErrors).length === 0,&#10;    [offerErrors]&#10;  )&#10;  const publishDisabled = useMemo(&#10;    () =&gt; !state.acceptedTerms || isPending,&#10;    [isPending, state.acceptedTerms]&#10;  )&#10;&#10;  const handleSaveDraft = useCallback(() =&gt; {&#10;    setAutosaveEnabled(true)&#10;    saveNow(serializableState)&#10;    toast.success(t('publishBook.draftSaved'))&#10;  }, [saveNow, serializableState, setAutosaveEnabled, t])&#10;&#10;  const handlePublish = useCallback(async () =&gt; {&#10;    const payload: PublishBookPayload = {&#10;      metadata: {&#10;        title: state.metadata.title,&#10;        author: state.metadata.author,&#10;        publisher: state.metadata.publisher || undefined,&#10;        year: state.metadata.year ? Number(state.metadata.year) : null,&#10;        language: state.metadata.language || undefined,&#10;        format: state.metadata.format || undefined,&#10;        isbn: state.metadata.isbn || undefined,&#10;        coverUrl,&#10;      },&#10;      images: state.images.map((image) =&gt; ({&#10;        id: image.id,&#10;        url: image.url,&#10;        source: image.source,&#10;      })),&#10;      offer: {&#10;        sale: state.offer.sale,&#10;        donation: state.offer.donation,&#10;        trade: state.offer.trade,&#10;        price: state.offer.sale&#10;          ? {&#10;              amount: Number(state.offer.priceAmount),&#10;              currency: state.offer.priceCurrency,&#10;            }&#10;          : null,&#10;        condition: state.offer&#10;          .condition as PublishBookPayload['offer']['condition'],&#10;        tradePreferences: state.offer.tradePreferences,&#10;        notes: state.offer.notes || undefined,&#10;        availability: state.offer.availability,&#10;        delivery: state.offer.delivery,&#10;      },&#10;      draft: false,&#10;    }&#10;&#10;    try {&#10;      const created = await mutateAsync(payload)&#10;      toast.success(t('publishBook.published'))&#10;      clear()&#10;      onPublished(created.id)&#10;    } catch {&#10;      toast.error(t('publishBook.publishError'))&#10;    }&#10;  }, [clear, coverUrl, mutateAsync, onPublished, state, t])&#10;&#10;  const resumeDraft = useCallback(() =&gt; {&#10;    setState(baseState)&#10;    setShowDraftPrompt(false)&#10;    setAutosaveEnabled(true)&#10;  }, [baseState, setAutosaveEnabled, setShowDraftPrompt, setState])&#10;&#10;  const discardDraft = useCallback(() =&gt; {&#10;    clear()&#10;    setState(initialState)&#10;    setShowDraftPrompt(false)&#10;    setAutosaveEnabled(true)&#10;  }, [clear, setAutosaveEnabled, setShowDraftPrompt, setState])&#10;&#10;  const handleSearchChange = useCallback(&#10;    (value: string) =&gt; {&#10;      setState((prev) =&gt; ({ ...prev, searchQuery: value }))&#10;    },&#10;    [setState]&#10;  )&#10;&#10;  const handleManualModeToggle = useCallback(&#10;    (checked: boolean) =&gt; {&#10;      setState((prev) =&gt; ({ ...prev, manualMode: checked }))&#10;    },&#10;    [setState]&#10;  )&#10;&#10;  const handleRetrySearch = useCallback(() =&gt; {&#10;    void refetch()&#10;  }, [refetch])&#10;&#10;  const handleAcceptedTermsChange = useCallback(&#10;    (checked: boolean) =&gt; {&#10;      setState((prev) =&gt; ({ ...prev, acceptedTerms: checked }))&#10;    },&#10;    [setState]&#10;  )&#10;&#10;  if (!isOpen) return null&#10;&#10;  return (&#10;    &lt;div className={styles.overlay} role=&quot;presentation&quot; aria-hidden={!isOpen}&gt;&#10;      {showDraftPrompt ? (&#10;        &lt;ResumeDraftPrompt&#10;          t={t}&#10;          onDiscard={discardDraft}&#10;          onResume={resumeDraft}&#10;        /&gt;&#10;      ) : (&#10;        &lt;div&#10;          className={styles.modal}&#10;          role=&quot;dialog&quot;&#10;          aria-modal=&quot;true&quot;&#10;          aria-labelledby=&quot;publish-book-title&quot;&#10;          ref={modalRef}&#10;        &gt;&#10;          &lt;header className={styles.header}&gt;&#10;            &lt;div className={styles.titleGroup}&gt;&#10;              &lt;h2 id=&quot;publish-book-title&quot;&gt;{t('publishBook.title')}&lt;/h2&gt;&#10;              &lt;span className={styles.toastInline}&gt;&#10;                {t('publishBook.subtitle')}&#10;              &lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className={styles.headerActions}&gt;&#10;              &lt;button&#10;                type=&quot;button&quot;&#10;                className={styles.closeButton}&#10;                onClick={closeWithConfirmation}&#10;              &gt;&#10;                {t('publishBook.cancel')}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/header&gt;&#10;&#10;          &lt;section className={styles.content}&gt;&#10;            &lt;PublishBookStepper&#10;              currentStep={state.step}&#10;              t={t}&#10;              stepOrder={stepOrder}&#10;              stepIndex={stepIndex}&#10;            /&gt;&#10;&#10;            &lt;div className={styles.stepContent}&gt;&#10;              {state.step === 'identify' &amp;&amp; (&#10;                &lt;IdentifyStep&#10;                  t={t}&#10;                  metadata={state.metadata}&#10;                  manualMode={state.manualMode}&#10;                  searchQuery={state.searchQuery}&#10;                  images={state.images}&#10;                  errors={identifyErrors}&#10;                  results={results}&#10;                  isFetching={isFetching}&#10;                  isError={isError}&#10;                  maxImages={MAX_IMAGES_UPLOAD}&#10;                  onMetadataChange={updateMetadata}&#10;                  onSearchChange={handleSearchChange}&#10;                  onManualModeToggle={handleManualModeToggle}&#10;                  onResultSelect={handleResult}&#10;                  onFiles={handleFiles}&#10;                  onRemoveImage={removeImage}&#10;                  onRetry={handleRetrySearch}&#10;                  onBlur={handleBlur}&#10;                /&gt;&#10;              )}&#10;&#10;              {state.step === 'offer' &amp;&amp; (&#10;                &lt;OfferStep&#10;                  t={t}&#10;                  offer={state.offer}&#10;                  errors={offerErrors}&#10;                  genres={genres}&#10;                  onOfferChange={updateOffer}&#10;                  onDeliveryChange={updateDelivery}&#10;                  onToggleTradePreference={toggleTradePreference}&#10;                  onBlur={handleBlur}&#10;                /&gt;&#10;              )}&#10;&#10;              {state.step === 'review' &amp;&amp; (&#10;                &lt;ReviewStep&#10;                  t={t}&#10;                  metadata={state.metadata}&#10;                  offer={state.offer}&#10;                  coverUrl={coverUrl}&#10;                  acceptedTerms={state.acceptedTerms}&#10;                  onAcceptedTermsChange={handleAcceptedTermsChange}&#10;                /&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/section&gt;&#10;&#10;          &lt;footer className={styles.actions}&gt;&#10;            &lt;div className={styles.ctaGroup}&gt;&#10;              &lt;button&#10;                type=&quot;button&quot;&#10;                className={styles.secondaryButton}&#10;                onClick={closeWithConfirmation}&#10;              &gt;&#10;                {t('publishBook.cancel')}&#10;              &lt;/button&gt;&#10;              &lt;button&#10;                type=&quot;button&quot;&#10;                className={styles.secondaryButton}&#10;                onClick={handleSaveDraft}&#10;              &gt;&#10;                {t('publishBook.saveDraft')}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className={styles.ctaGroup}&gt;&#10;              {state.step !== 'identify' &amp;&amp; (&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  className={styles.secondaryButton}&#10;                  onClick={previousStep}&#10;                &gt;&#10;                  {t('publishBook.back')}&#10;                &lt;/button&gt;&#10;              )}&#10;              {state.step !== 'review' &amp;&amp; (&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  className={styles.primaryButton}&#10;                  onClick={nextStep}&#10;                  disabled={&#10;                    (state.step === 'identify' &amp;&amp; !canProceedIdentify) ||&#10;                    (state.step === 'offer' &amp;&amp; !canProceedOffer)&#10;                  }&#10;                &gt;&#10;                  {t('publishBook.next')}&#10;                &lt;/button&gt;&#10;              )}&#10;              {state.step === 'review' &amp;&amp; (&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  className={styles.primaryButton}&#10;                  onClick={handlePublish}&#10;                  disabled={publishDisabled}&#10;                &gt;&#10;                  {isPending&#10;                    ? t('publishBook.publishing')&#10;                    : t('publishBook.publish')}&#10;                &lt;/button&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/footer&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  )&#10;}&#10;" />
              <option name="updatedContent" value="import { useBookSearch } from '@hooks/api/useBookSearch'&#10;import { usePublishBook } from '@hooks/api/usePublishBook'&#10;import { useFocusTrap } from '@hooks/useFocusTrap'&#10;import { usePublishDraft } from '@hooks/usePublishDraft'&#10;import { stripDraftMeta } from '@utils/drafts'&#10;import isEqual from 'lodash/isEqual'&#10;import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'&#10;import { useTranslation } from 'react-i18next'&#10;import { toast } from 'react-toastify'&#10;&#10;import { PublishBookPayload } from '@src/api/books/publishBook.types'&#10;import { ApiBookSearchResult } from '@src/api/books/searchBooks.types'&#10;import { MAX_IMAGES_UPLOAD } from '@src/constants/constants'&#10;&#10;import { IdentifyStep } from './components/IdentifyStep'&#10;import { OfferStep } from './components/OfferStep'&#10;import { PublishBookStepper } from './components/PublishBookStepper'&#10;import { ResumeDraftPrompt } from './components/ResumeDraftPrompt'&#10;import { ReviewStep } from './components/ReviewStep'&#10;import {&#10;  STORAGE_KEY,&#10;  genres,&#10;  initialState,&#10;  stepIndex,&#10;  stepOrder,&#10;  toSerializableDraft,&#10;} from './PublishBookModal.constants'&#10;import styles from './PublishBookModal.module.scss'&#10;import {&#10;  PublishBookDraftState,&#10;  PublishBookFormState,&#10;  PublishBookImage,&#10;  PublishBookMetadata,&#10;  PublishBookOffer,&#10;} from './PublishBookModal.types'&#10;import {&#10;  ensureCover,&#10;  getPreviewCover,&#10;  sanitizeDraft,&#10;} from './PublishBookModal.utils'&#10;import { useDebouncedValue } from './useDebouncedValue'&#10;&#10;type PublishBookModalProps = {&#10;  isOpen: boolean&#10;  onClose: () =&gt; void&#10;  onPublished: (bookId: string) =&gt; void&#10;}&#10;&#10;const usePublishBookDraft = () =&gt;&#10;  usePublishDraft&lt;PublishBookDraftState&gt;({ storageKey: STORAGE_KEY })&#10;&#10;const usePublishState = (draft: PublishBookDraftState | null) =&gt; {&#10;  const [state, setState] = useState&lt;PublishBookFormState&gt;(initialState)&#10;  const [showDraftPrompt, setShowDraftPrompt] = useState(false)&#10;  const [autosaveEnabled, setAutosaveEnabled] = useState&lt;boolean&gt;(() =&gt; !draft)&#10;&#10;  return {&#10;    state,&#10;    setState,&#10;    showDraftPrompt,&#10;    setShowDraftPrompt,&#10;    autosaveEnabled,&#10;    setAutosaveEnabled,&#10;  }&#10;}&#10;&#10;const useDraftInitialization = (&#10;  isOpen: boolean,&#10;  draft: PublishBookDraftState | null,&#10;  setState: React.Dispatch&lt;React.SetStateAction&lt;PublishBookFormState&gt;&gt;,&#10;  setShowDraftPrompt: React.Dispatch&lt;React.SetStateAction&lt;boolean&gt;&gt;,&#10;  setAutosaveEnabled: React.Dispatch&lt;React.SetStateAction&lt;boolean&gt;&gt;&#10;) =&gt; {&#10;  const initializedRef = useRef(false)&#10;&#10;  useEffect(() =&gt; {&#10;    if (!isOpen) {&#10;      initializedRef.current = false&#10;      setShowDraftPrompt(false)&#10;      setAutosaveEnabled(true)&#10;      return&#10;    }&#10;&#10;    if (initializedRef.current) return&#10;&#10;    initializedRef.current = true&#10;    if (draft) {&#10;      setShowDraftPrompt(true)&#10;      setAutosaveEnabled(false)&#10;    } else {&#10;      setState(initialState)&#10;      setAutosaveEnabled(true)&#10;    }&#10;  }, [draft, isOpen, setAutosaveEnabled, setShowDraftPrompt, setState])&#10;}&#10;&#10;const useBodyScrollLock = (isOpen: boolean) =&gt; {&#10;  useEffect(() =&gt; {&#10;    if (!isOpen) return&#10;    document.body.style.overflow = 'hidden'&#10;    return () =&gt; {&#10;      document.body.style.overflow = ''&#10;    }&#10;  }, [isOpen])&#10;}&#10;&#10;// Safe whitelist + type guard for shippingPayer&#10;type ShippingPayer = PublishBookOffer['delivery']['shippingPayer']&#10;const SHIPPING_PAYER_VALUES: readonly ShippingPayer[] = ['owner', 'requester', 'split'] as const&#10;const isShippingPayer = (value: string): value is ShippingPayer =&gt;&#10;  (SHIPPING_PAYER_VALUES as readonly string[]).includes(value)&#10;&#10;export const PublishBookModal: React.FC&lt;PublishBookModalProps&gt; = ({&#10;  isOpen,&#10;  onClose,&#10;  onPublished,&#10;}) =&gt; {&#10;  const { t, i18n } = useTranslation()&#10;  const {&#10;    draft: storedDraft,&#10;    saveNow,&#10;    scheduleSave,&#10;    clear,&#10;  } = usePublishBookDraft()&#10;  const draft = useMemo(() =&gt; stripDraftMeta(storedDraft), [storedDraft])&#10;  const {&#10;    state,&#10;    setState,&#10;    showDraftPrompt,&#10;    setShowDraftPrompt,&#10;    autosaveEnabled,&#10;    setAutosaveEnabled,&#10;  } = usePublishState(draft)&#10;  const modalRef = useRef&lt;HTMLDivElement&gt;(null)&#10;&#10;  useDraftInitialization(&#10;    isOpen,&#10;    draft,&#10;    setState,&#10;    setShowDraftPrompt,&#10;    setAutosaveEnabled&#10;  )&#10;  useBodyScrollLock(isOpen)&#10;&#10;  const baselineDraft = useMemo&lt;PublishBookDraftState&gt;(&#10;    () =&gt; draft ?? toSerializableDraft(initialState),&#10;    [draft]&#10;  )&#10;  const serializableState = useMemo&lt;PublishBookDraftState&gt;(&#10;    () =&gt; toSerializableDraft(state),&#10;    [state]&#10;  )&#10;&#10;  const debouncedQuery = useDebouncedValue(state.searchQuery)&#10;  const {&#10;    data: results,&#10;    isFetching,&#10;    isError,&#10;    refetch,&#10;  } = useBookSearch(debouncedQuery)&#10;  const { mutateAsync, isPending } = usePublishBook()&#10;  const baseState = useMemo(() =&gt; sanitizeDraft(draft), [draft])&#10;&#10;  const closeWithConfirmation = useCallback(() =&gt; {&#10;    const hasChanges = !isEqual(serializableState, baselineDraft)&#10;    if (hasChanges) {&#10;      const confirmed = window.confirm(t('publishBook.confirmClose'))&#10;      if (!confirmed) {&#10;        return&#10;      }&#10;    }&#10;    onClose()&#10;  }, [baselineDraft, onClose, serializableState, t])&#10;&#10;  useFocusTrap({&#10;    containerRef: modalRef,&#10;    active: isOpen &amp;&amp; !showDraftPrompt,&#10;    onEscape: closeWithConfirmation,&#10;  })&#10;&#10;  useEffect(() =&gt; {&#10;    if (!isOpen) return&#10;    const handleBeforeUnload = (event: BeforeUnloadEvent) =&gt; {&#10;      if (!isEqual(serializableState, baselineDraft)) {&#10;        event.preventDefault()&#10;        event.returnValue = ''&#10;      }&#10;    }&#10;    window.addEventListener('beforeunload', handleBeforeUnload)&#10;    return () =&gt; {&#10;      window.removeEventListener('beforeunload', handleBeforeUnload)&#10;    }&#10;  }, [baselineDraft, isOpen, serializableState])&#10;&#10;  useEffect(() =&gt; {&#10;    if (!isOpen || showDraftPrompt || !autosaveEnabled) return&#10;    if (isEqual(serializableState, baselineDraft)) return&#10;    scheduleSave(serializableState)&#10;  }, [&#10;    autosaveEnabled,&#10;    baselineDraft,&#10;    isOpen,&#10;    scheduleSave,&#10;    serializableState,&#10;    showDraftPrompt,&#10;  ])&#10;&#10;  // Single memoized blur handler reused across all inputs&#10;  const handleBlur = useCallback&lt;React.FocusEventHandler&lt;HTMLElement&gt;&gt;(&#10;    () =&gt; {&#10;      // Pass the current serializable draft to scheduleSave (fixes TS2554)&#10;      scheduleSave(serializableState)&#10;    },&#10;    [scheduleSave, serializableState]&#10;  )&#10;&#10;  const updateMetadata = useCallback(&#10;    (update: Partial&lt;PublishBookMetadata&gt;) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; {&#10;        const metadata = { ...prev.metadata, ...update }&#10;        const nextImages = ensureCover(prev.images, metadata.coverUrl)&#10;        return { ...prev, metadata, images: nextImages }&#10;      })&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const updateOffer = useCallback(&#10;    (update: Partial&lt;PublishBookOffer&gt;) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        offer: { ...prev.offer, ...update },&#10;      }))&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const updateDelivery = useCallback(&#10;    (update: Partial&lt;PublishBookOffer['delivery']&gt;) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        offer: {&#10;          ...prev.offer,&#10;          delivery: { ...prev.offer.delivery, ...update },&#10;        },&#10;      }))&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const toggleTradePreference = useCallback(&#10;    (genre: PublishBookOffer['tradePreferences'][number]) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; {&#10;        const isActive = prev.offer.tradePreferences.includes(genre)&#10;        const tradePreferences = isActive&#10;          ? prev.offer.tradePreferences.filter((item) =&gt; item !== genre)&#10;          : [...prev.offer.tradePreferences, genre]&#10;        return {&#10;          ...prev,&#10;          offer: { ...prev.offer, tradePreferences },&#10;        }&#10;      })&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const handleResult = useCallback(&#10;    (result: ApiBookSearchResult) =&gt; {&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        metadata: {&#10;          ...prev.metadata,&#10;          title: result.title ?? prev.metadata.title,&#10;          author: result.author ?? prev.metadata.author,&#10;          publisher: result.publisher ?? prev.metadata.publisher,&#10;          year: result.year ? String(result.year) : prev.metadata.year,&#10;          language:&#10;            result.language ?? prev.metadata.language ?? i18n.language ?? '',&#10;          format: result.format ?? prev.metadata.format,&#10;          isbn: result.isbn ?? prev.metadata.isbn,&#10;          coverUrl: result.coverUrl ?? prev.metadata.coverUrl,&#10;        },&#10;        manualMode: false,&#10;        images: ensureCover(&#10;          prev.images,&#10;          result.coverUrl ?? prev.metadata.coverUrl&#10;        ),&#10;      }))&#10;      toast.info(t('publishBook.prefilled'))&#10;      setAutosaveEnabled(true)&#10;    },&#10;    [i18n.language, setAutosaveEnabled, setState, t]&#10;  )&#10;&#10;  const handleFiles = useCallback(&#10;    async (files: FileList | null) =&gt; {&#10;      if (!files) return&#10;      const fileArray = Array.from(files).slice(0, MAX_IMAGES_UPLOAD)&#10;      const uploads = await Promise.all(&#10;        fileArray.map(&#10;          (file, index) =&gt;&#10;            new Promise&lt;PublishBookImage&gt;((resolve, reject) =&gt; {&#10;              const reader = new FileReader()&#10;              reader.onload = () =&gt;&#10;                resolve({&#10;                  id: `${file.name}-${Date.now()}-${index}`,&#10;                  url: String(reader.result),&#10;                  source: 'upload',&#10;                  name: file.name,&#10;                })&#10;              reader.onerror = () =&gt;&#10;                reject(reader.error ?? new Error('Failed to read file'))&#10;              reader.readAsDataURL(file)&#10;            })&#10;        )&#10;      )&#10;      setState((prev) =&gt; {&#10;        const nextImages = [...prev.images, ...uploads].slice(&#10;          0,&#10;          MAX_IMAGES_UPLOAD&#10;        )&#10;        return { ...prev, images: nextImages }&#10;      })&#10;      setAutosaveEnabled(true)&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const removeImage = useCallback(&#10;    (id: string) =&gt; {&#10;      setAutosaveEnabled(true)&#10;      setState((prev) =&gt; ({&#10;        ...prev,&#10;        images: prev.images.filter((image) =&gt; image.id !== id),&#10;      }))&#10;    },&#10;    [setAutosaveEnabled, setState]&#10;  )&#10;&#10;  const nextStep = useCallback(() =&gt; {&#10;    setAutosaveEnabled(true)&#10;    setState((prev) =&gt; ({&#10;      ...prev,&#10;      step: prev.step === 'identify' ? 'offer' : 'review',&#10;    }))&#10;  }, [setAutosaveEnabled, setState])&#10;&#10;  const previousStep = useCallback(() =&gt; {&#10;    setAutosaveEnabled(true)&#10;    setState((prev) =&gt; ({&#10;      ...prev,&#10;      step: prev.step === 'review' ? 'offer' : 'identify',&#10;    }))&#10;  }, [setAutosaveEnabled, setState])&#10;&#10;  const coverUrl = useMemo(&#10;    () =&gt; getPreviewCover(state.images, state.metadata.coverUrl),&#10;    [state.images, state.metadata.coverUrl]&#10;  )&#10;&#10;  const identifyErrors = useMemo(() =&gt; {&#10;    const errors: Record&lt;string, string&gt; = {}&#10;    if (!state.metadata.title.trim()) {&#10;      errors.title = t('publishBook.errors.title')&#10;    }&#10;    if (!state.metadata.author.trim()) {&#10;      errors.author = t('publishBook.errors.author')&#10;    }&#10;    if (!state.metadata.language.trim()) {&#10;      errors.language = t('publishBook.errors.language')&#10;    }&#10;    if (!state.metadata.format.trim()) {&#10;      errors.format = t('publishBook.errors.format')&#10;    }&#10;    if (!coverUrl) {&#10;      errors.images = t('publishBook.errors.image')&#10;    }&#10;    return errors&#10;  }, [coverUrl, state.metadata, t])&#10;&#10;  const offerErrors = useMemo(() =&gt; {&#10;    const errors: Record&lt;string, string&gt; = {}&#10;    if (!state.offer.condition) {&#10;      errors.condition = t('publishBook.errors.condition')&#10;    }&#10;    if (!state.offer.sale &amp;&amp; !state.offer.trade &amp;&amp; !state.offer.donation) {&#10;      errors.modes = t('publishBook.errors.modes')&#10;    }&#10;    if (state.offer.sale) {&#10;      const amount = Number(state.offer.priceAmount)&#10;      if (!state.offer.priceAmount || Number.isNaN(amount) || amount &lt;= 0) {&#10;        errors.price = t('publishBook.errors.price')&#10;      }&#10;    }&#10;    return errors&#10;  }, [state.offer, t])&#10;&#10;  const canProceedIdentify = useMemo(&#10;    () =&gt; Object.keys(identifyErrors).length === 0,&#10;    [identifyErrors]&#10;  )&#10;  const canProceedOffer = useMemo(&#10;    () =&gt; Object.keys(offerErrors).length === 0,&#10;    [offerErrors]&#10;  )&#10;  const publishDisabled = useMemo(&#10;    () =&gt; !state.acceptedTerms || isPending,&#10;    [isPending, state.acceptedTerms]&#10;  )&#10;&#10;  const handleSaveDraft = useCallback(() =&gt; {&#10;    setAutosaveEnabled(true)&#10;    saveNow(serializableState)&#10;    toast.success(t('publishBook.draftSaved'))&#10;  }, [saveNow, serializableState, setAutosaveEnabled, t])&#10;&#10;  const handlePublish = useCallback(async () =&gt; {&#10;    const payload: PublishBookPayload = {&#10;      metadata: {&#10;        title: state.metadata.title,&#10;        author: state.metadata.author,&#10;        publisher: state.metadata.publisher || undefined,&#10;        year: state.metadata.year ? Number(state.metadata.year) : null,&#10;        language: state.metadata.language || undefined,&#10;        format: state.metadata.format || undefined,&#10;        isbn: state.metadata.isbn || undefined,&#10;        coverUrl,&#10;      },&#10;      images: state.images.map((image) =&gt; ({&#10;        id: image.id,&#10;        url: image.url,&#10;        source: image.source,&#10;      })),&#10;      offer: {&#10;        sale: state.offer.sale,&#10;        donation: state.offer.donation,&#10;        trade: state.offer.trade,&#10;        price: state.offer.sale&#10;          ? {&#10;              amount: Number(state.offer.priceAmount),&#10;              currency: state.offer.priceCurrency,&#10;            }&#10;          : null,&#10;        condition: state.offer&#10;          .condition as PublishBookPayload['offer']['condition'],&#10;        tradePreferences: state.offer.tradePreferences,&#10;        notes: state.offer.notes || undefined,&#10;        availability: state.offer.availability,&#10;        delivery: state.offer.delivery,&#10;      },&#10;      draft: false,&#10;    }&#10;&#10;    try {&#10;      const created = await mutateAsync(payload)&#10;      toast.success(t('publishBook.published'))&#10;      clear()&#10;      onPublished(created.id)&#10;    } catch {&#10;      toast.error(t('publishBook.publishError'))&#10;    }&#10;  }, [clear, coverUrl, mutateAsync, onPublished, state, t])&#10;&#10;  const resumeDraft = useCallback(() =&gt; {&#10;    setState(baseState)&#10;    setShowDraftPrompt(false)&#10;    setAutosaveEnabled(true)&#10;  }, [baseState, setAutosaveEnabled, setShowDraftPrompt, setState])&#10;&#10;  const discardDraft = useCallback(() =&gt; {&#10;    clear()&#10;    setState(initialState)&#10;    setShowDraftPrompt(false)&#10;    setAutosaveEnabled(true)&#10;  }, [clear, setAutosaveEnabled, setShowDraftPrompt, setState])&#10;&#10;  const handleSearchChange = useCallback(&#10;    (value: string) =&gt; {&#10;      setState((prev) =&gt; ({ ...prev, searchQuery: value }))&#10;    },&#10;    [setState]&#10;  )&#10;&#10;  const handleManualModeToggle = useCallback(&#10;    (checked: boolean) =&gt; {&#10;      setState((prev) =&gt; ({ ...prev, manualMode: checked }))&#10;    },&#10;    [setState]&#10;  )&#10;&#10;  const handleRetrySearch = useCallback(() =&gt; {&#10;    void refetch()&#10;  }, [refetch])&#10;&#10;  const handleAcceptedTermsChange = useCallback(&#10;    (checked: boolean) =&gt; {&#10;      setState((prev) =&gt; ({ ...prev, acceptedTerms: checked }))&#10;    },&#10;    [setState]&#10;  )&#10;&#10;  if (!isOpen) return null&#10;&#10;  return (&#10;    &lt;div className={styles.overlay} role=&quot;presentation&quot; aria-hidden={!isOpen}&gt;&#10;      {showDraftPrompt ? (&#10;        &lt;ResumeDraftPrompt&#10;          t={t}&#10;          onDiscard={discardDraft}&#10;          onResume={resumeDraft}&#10;        /&gt;&#10;      ) : (&#10;        &lt;div&#10;          className={styles.modal}&#10;          role=&quot;dialog&quot;&#10;          aria-modal=&quot;true&quot;&#10;          aria-labelledby=&quot;publish-book-title&quot;&#10;          ref={modalRef}&#10;        &gt;&#10;          &lt;header className={styles.header}&gt;&#10;            &lt;div className={styles.titleGroup}&gt;&#10;              &lt;h2 id=&quot;publish-book-title&quot;&gt;{t('publishBook.title')}&lt;/h2&gt;&#10;              &lt;span className={styles.toastInline}&gt;&#10;                {t('publishBook.subtitle')}&#10;              &lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className={styles.headerActions}&gt;&#10;              &lt;button&#10;                type=&quot;button&quot;&#10;                className={styles.closeButton}&#10;                onClick={closeWithConfirmation}&#10;              &gt;&#10;                {t('publishBook.cancel')}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/header&gt;&#10;&#10;          &lt;section className={styles.content}&gt;&#10;            &lt;PublishBookStepper&#10;              currentStep={state.step}&#10;              t={t}&#10;              stepOrder={stepOrder}&#10;              stepIndex={stepIndex}&#10;            /&gt;&#10;&#10;            &lt;div className={styles.stepContent}&gt;&#10;              {state.step === 'identify' &amp;&amp; (&#10;                &lt;IdentifyStep&#10;                  t={t}&#10;                  metadata={state.metadata}&#10;                  manualMode={state.manualMode}&#10;                  searchQuery={state.searchQuery}&#10;                  images={state.images}&#10;                  errors={identifyErrors}&#10;                  results={results}&#10;                  isFetching={isFetching}&#10;                  isError={isError}&#10;                  maxImages={MAX_IMAGES_UPLOAD}&#10;                  onMetadataChange={updateMetadata}&#10;                  onSearchChange={handleSearchChange}&#10;                  onManualModeToggle={handleManualModeToggle}&#10;                  onResultSelect={handleResult}&#10;                  onFiles={handleFiles}&#10;                  onRemoveImage={removeImage}&#10;                  onRetry={handleRetrySearch}&#10;                  onBlur={handleBlur}&#10;                /&gt;&#10;              )}&#10;&#10;              {state.step === 'offer' &amp;&amp; (&#10;                &lt;OfferStep&#10;                  t={t}&#10;                  offer={state.offer}&#10;                  errors={offerErrors}&#10;                  genres={genres}&#10;                  onOfferChange={updateOffer}&#10;                  onDeliveryChange={updateDelivery}&#10;                  onToggleTradePreference={toggleTradePreference}&#10;                  onBlur={handleBlur}&#10;                /&gt;&#10;              )}&#10;&#10;              {state.step === 'review' &amp;&amp; (&#10;                &lt;ReviewStep&#10;                  t={t}&#10;                  metadata={state.metadata}&#10;                  offer={state.offer}&#10;                  coverUrl={coverUrl}&#10;                  acceptedTerms={state.acceptedTerms}&#10;                  onAcceptedTermsChange={handleAcceptedTermsChange}&#10;                /&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/section&gt;&#10;&#10;          &lt;footer className={styles.actions}&gt;&#10;            &lt;div className={styles.ctaGroup}&gt;&#10;              &lt;button&#10;                type=&quot;button&quot;&#10;                className={styles.secondaryButton}&#10;                onClick={closeWithConfirmation}&#10;              &gt;&#10;                {t('publishBook.cancel')}&#10;              &lt;/button&gt;&#10;              &lt;button&#10;                type=&quot;button&quot;&#10;                className={styles.secondaryButton}&#10;                onClick={handleSaveDraft}&#10;              &gt;&#10;                {t('publishBook.saveDraft')}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className={styles.ctaGroup}&gt;&#10;              {state.step !== 'identify' &amp;&amp; (&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  className={styles.secondaryButton}&#10;                  onClick={previousStep}&#10;                &gt;&#10;                  {t('publishBook.back')}&#10;                &lt;/button&gt;&#10;              )}&#10;              {state.step !== 'review' &amp;&amp; (&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  className={styles.primaryButton}&#10;                  onClick={nextStep}&#10;                  disabled={&#10;                    (state.step === 'identify' &amp;&amp; !canProceedIdentify) ||&#10;                    (state.step === 'offer' &amp;&amp; !canProceedOffer)&#10;                  }&#10;                &gt;&#10;                  {t('publishBook.next')}&#10;                &lt;/button&gt;&#10;              )}&#10;              {state.step === 'review' &amp;&amp; (&#10;                &lt;button&#10;                  type=&quot;button&quot;&#10;                  className={styles.primaryButton}&#10;                  onClick={handlePublish}&#10;                  disabled={publishDisabled}&#10;                &gt;&#10;                  {isPending&#10;                    ? t('publishBook.publishing')&#10;                    : t('publishBook.publish')}&#10;                &lt;/button&gt;&#10;              )}&#10;            &lt;/div&gt;&#10;          &lt;/footer&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>